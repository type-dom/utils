"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildExplicitTypeScriptDependencies = void 0;
const target_project_locator_1 = require("./target-project-locator");
const project_graph_1 = require("../../../../config/project-graph");
const path_1 = require("path");
const workspace_root_1 = require("../../../../utils/workspace-root");
const path_2 = require("../../../../utils/path");
const project_graph_builder_1 = require("../../../../project-graph/project-graph-builder");
function isRoot(graph, projectName) {
    return graph.nodes[projectName]?.data?.root === '.';
}
function convertImportToDependency(importExpr, sourceFile, source, dependencyType, targetProjectLocator) {
    const target = targetProjectLocator.findProjectWithImport(importExpr, sourceFile) ??
        `npm:${importExpr}`;
    return {
        source,
        target,
        sourceFile,
        dependencyType,
    };
}
function buildExplicitTypeScriptDependencies({ fileMap, graph, }) {
    const targetProjectLocator = new target_project_locator_1.TargetProjectLocator(graph.nodes, graph.externalNodes);
    const res = [];
    const filesToProcess = {};
    const moduleExtensions = ['.ts', '.js', '.tsx', '.jsx', '.mts', '.mjs'];
    for (const [project, fileData] of Object.entries(fileMap)) {
        filesToProcess[project] ??= [];
        for (const { file } of fileData) {
            if (moduleExtensions.some((ext) => file.endsWith(ext))) {
                filesToProcess[project].push((0, path_1.join)(workspace_root_1.workspaceRoot, file));
            }
        }
    }
    const { findImports } = require('../../../../native');
    const imports = findImports(filesToProcess);
    for (const { sourceProject, file, staticImportExpressions, dynamicImportExpressions, } of imports) {
        const normalizedFilePath = (0, path_2.normalizePath)((0, path_1.relative)(workspace_root_1.workspaceRoot, file));
        for (const importExpr of staticImportExpressions) {
            const dependency = convertImportToDependency(importExpr, normalizedFilePath, sourceProject, project_graph_1.DependencyType.static, targetProjectLocator);
            // TODO: These edges technically should be allowed but we need to figure out how to separate config files out from root
            if (isRoot(graph, dependency.source) ||
                !isRoot(graph, dependency.target)) {
                res.push(dependency);
            }
        }
        for (const importExpr of dynamicImportExpressions) {
            const dependency = convertImportToDependency(importExpr, normalizedFilePath, sourceProject, project_graph_1.DependencyType.dynamic, targetProjectLocator);
            // TODO: These edges technically should be allowed but we need to figure out how to separate config files out from root
            if (isRoot(graph, dependency.source) ||
                !isRoot(graph, dependency.target)) {
                (0, project_graph_builder_1.validateDependency)(graph, dependency);
                res.push(dependency);
            }
        }
    }
    return res;
}
exports.buildExplicitTypeScriptDependencies = buildExplicitTypeScriptDependencies;
