"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProjectFileMap = exports.createProjectFileMap = exports.createProjectFileMapUsingProjectGraph = void 0;
const find_project_for_path_1 = require("./utils/find-project-for-path");
const client_1 = require("../daemon/client/client");
const project_graph_1 = require("./project-graph");
const file_hasher_1 = require("../hasher/file-hasher");
async function createProjectFileMapUsingProjectGraph(graph) {
    const configs = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(graph);
    let files;
    if (client_1.daemonClient.enabled()) {
        files = await client_1.daemonClient.getAllFileData();
    }
    else {
        await file_hasher_1.fileHasher.ensureInitialized();
        files = file_hasher_1.fileHasher.allFileData();
    }
    return createProjectFileMap(configs, files).projectFileMap;
}
exports.createProjectFileMapUsingProjectGraph = createProjectFileMapUsingProjectGraph;
function createProjectFileMap(projectsConfigurations, allWorkspaceFiles) {
    const projectFileMap = {};
    const projectRootMappings = (0, find_project_for_path_1.createProjectRootMappingsFromProjectConfigurations)(projectsConfigurations.projects);
    for (const projectName of Object.keys(projectsConfigurations.projects)) {
        projectFileMap[projectName] ??= [];
    }
    for (const f of allWorkspaceFiles) {
        const projectFileMapKey = (0, find_project_for_path_1.findProjectForPath)(f.file, projectRootMappings);
        const matchingProjectFiles = projectFileMap[projectFileMapKey];
        if (matchingProjectFiles) {
            matchingProjectFiles.push(f);
        }
    }
    return { projectFileMap, allWorkspaceFiles };
}
exports.createProjectFileMap = createProjectFileMap;
function updateProjectFileMap(projectsConfigurations, projectFileMap, allWorkspaceFiles, updatedFiles, deletedFiles) {
    const projectRootMappings = (0, find_project_for_path_1.createProjectRootMappingsFromProjectConfigurations)(projectsConfigurations);
    for (const f of updatedFiles.keys()) {
        const matchingProjectFiles = projectFileMap[(0, find_project_for_path_1.findProjectForPath)(f, projectRootMappings)] ?? [];
        if (matchingProjectFiles) {
            const fileData = matchingProjectFiles.find((t) => t.file === f);
            if (fileData) {
                fileData.hash = updatedFiles.get(f);
            }
            else {
                matchingProjectFiles.push({
                    file: f,
                    hash: updatedFiles.get(f),
                });
            }
        }
        const fileData = allWorkspaceFiles.find((t) => t.file === f);
        if (fileData) {
            fileData.hash = updatedFiles.get(f);
        }
        else {
            allWorkspaceFiles.push({
                file: f,
                hash: updatedFiles.get(f),
            });
        }
    }
    for (const f of deletedFiles) {
        const matchingProjectFiles = projectFileMap[(0, find_project_for_path_1.findProjectForPath)(f, projectRootMappings)] ?? [];
        if (matchingProjectFiles) {
            const index = matchingProjectFiles.findIndex((t) => t.file === f);
            if (index > -1) {
                matchingProjectFiles.splice(index, 1);
            }
        }
        const index = allWorkspaceFiles.findIndex((t) => t.file === f);
        if (index > -1) {
            allWorkspaceFiles.splice(index, 1);
        }
    }
    return { projectFileMap, allWorkspaceFiles };
}
exports.updateProjectFileMap = updateProjectFileMap;
